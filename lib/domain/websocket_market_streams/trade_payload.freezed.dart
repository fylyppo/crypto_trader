// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'trade_payload.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$TradePayload {
  String get eventType => throw _privateConstructorUsedError;
  String get symbol => throw _privateConstructorUsedError;
  String get price => throw _privateConstructorUsedError;
  String get quantity => throw _privateConstructorUsedError;
  int get eventTime => throw _privateConstructorUsedError;
  int get tradeID => throw _privateConstructorUsedError;
  int get buyerOrderID => throw _privateConstructorUsedError;
  int get sellerOrderID => throw _privateConstructorUsedError;
  int get tradeTime => throw _privateConstructorUsedError;
  bool get marketMaker => throw _privateConstructorUsedError;
  bool get ignore => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $TradePayloadCopyWith<TradePayload> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TradePayloadCopyWith<$Res> {
  factory $TradePayloadCopyWith(
          TradePayload value, $Res Function(TradePayload) then) =
      _$TradePayloadCopyWithImpl<$Res>;
  $Res call(
      {String eventType,
      String symbol,
      String price,
      String quantity,
      int eventTime,
      int tradeID,
      int buyerOrderID,
      int sellerOrderID,
      int tradeTime,
      bool marketMaker,
      bool ignore});
}

/// @nodoc
class _$TradePayloadCopyWithImpl<$Res> implements $TradePayloadCopyWith<$Res> {
  _$TradePayloadCopyWithImpl(this._value, this._then);

  final TradePayload _value;
  // ignore: unused_field
  final $Res Function(TradePayload) _then;

  @override
  $Res call({
    Object? eventType = freezed,
    Object? symbol = freezed,
    Object? price = freezed,
    Object? quantity = freezed,
    Object? eventTime = freezed,
    Object? tradeID = freezed,
    Object? buyerOrderID = freezed,
    Object? sellerOrderID = freezed,
    Object? tradeTime = freezed,
    Object? marketMaker = freezed,
    Object? ignore = freezed,
  }) {
    return _then(_value.copyWith(
      eventType: eventType == freezed
          ? _value.eventType
          : eventType // ignore: cast_nullable_to_non_nullable
              as String,
      symbol: symbol == freezed
          ? _value.symbol
          : symbol // ignore: cast_nullable_to_non_nullable
              as String,
      price: price == freezed
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as String,
      quantity: quantity == freezed
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as String,
      eventTime: eventTime == freezed
          ? _value.eventTime
          : eventTime // ignore: cast_nullable_to_non_nullable
              as int,
      tradeID: tradeID == freezed
          ? _value.tradeID
          : tradeID // ignore: cast_nullable_to_non_nullable
              as int,
      buyerOrderID: buyerOrderID == freezed
          ? _value.buyerOrderID
          : buyerOrderID // ignore: cast_nullable_to_non_nullable
              as int,
      sellerOrderID: sellerOrderID == freezed
          ? _value.sellerOrderID
          : sellerOrderID // ignore: cast_nullable_to_non_nullable
              as int,
      tradeTime: tradeTime == freezed
          ? _value.tradeTime
          : tradeTime // ignore: cast_nullable_to_non_nullable
              as int,
      marketMaker: marketMaker == freezed
          ? _value.marketMaker
          : marketMaker // ignore: cast_nullable_to_non_nullable
              as bool,
      ignore: ignore == freezed
          ? _value.ignore
          : ignore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$$_TradePayloadCopyWith<$Res>
    implements $TradePayloadCopyWith<$Res> {
  factory _$$_TradePayloadCopyWith(
          _$_TradePayload value, $Res Function(_$_TradePayload) then) =
      __$$_TradePayloadCopyWithImpl<$Res>;
  @override
  $Res call(
      {String eventType,
      String symbol,
      String price,
      String quantity,
      int eventTime,
      int tradeID,
      int buyerOrderID,
      int sellerOrderID,
      int tradeTime,
      bool marketMaker,
      bool ignore});
}

/// @nodoc
class __$$_TradePayloadCopyWithImpl<$Res>
    extends _$TradePayloadCopyWithImpl<$Res>
    implements _$$_TradePayloadCopyWith<$Res> {
  __$$_TradePayloadCopyWithImpl(
      _$_TradePayload _value, $Res Function(_$_TradePayload) _then)
      : super(_value, (v) => _then(v as _$_TradePayload));

  @override
  _$_TradePayload get _value => super._value as _$_TradePayload;

  @override
  $Res call({
    Object? eventType = freezed,
    Object? symbol = freezed,
    Object? price = freezed,
    Object? quantity = freezed,
    Object? eventTime = freezed,
    Object? tradeID = freezed,
    Object? buyerOrderID = freezed,
    Object? sellerOrderID = freezed,
    Object? tradeTime = freezed,
    Object? marketMaker = freezed,
    Object? ignore = freezed,
  }) {
    return _then(_$_TradePayload(
      eventType: eventType == freezed
          ? _value.eventType
          : eventType // ignore: cast_nullable_to_non_nullable
              as String,
      symbol: symbol == freezed
          ? _value.symbol
          : symbol // ignore: cast_nullable_to_non_nullable
              as String,
      price: price == freezed
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as String,
      quantity: quantity == freezed
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as String,
      eventTime: eventTime == freezed
          ? _value.eventTime
          : eventTime // ignore: cast_nullable_to_non_nullable
              as int,
      tradeID: tradeID == freezed
          ? _value.tradeID
          : tradeID // ignore: cast_nullable_to_non_nullable
              as int,
      buyerOrderID: buyerOrderID == freezed
          ? _value.buyerOrderID
          : buyerOrderID // ignore: cast_nullable_to_non_nullable
              as int,
      sellerOrderID: sellerOrderID == freezed
          ? _value.sellerOrderID
          : sellerOrderID // ignore: cast_nullable_to_non_nullable
              as int,
      tradeTime: tradeTime == freezed
          ? _value.tradeTime
          : tradeTime // ignore: cast_nullable_to_non_nullable
              as int,
      marketMaker: marketMaker == freezed
          ? _value.marketMaker
          : marketMaker // ignore: cast_nullable_to_non_nullable
              as bool,
      ignore: ignore == freezed
          ? _value.ignore
          : ignore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_TradePayload implements _TradePayload {
  const _$_TradePayload(
      {required this.eventType,
      required this.symbol,
      required this.price,
      required this.quantity,
      required this.eventTime,
      required this.tradeID,
      required this.buyerOrderID,
      required this.sellerOrderID,
      required this.tradeTime,
      required this.marketMaker,
      required this.ignore});

  @override
  final String eventType;
  @override
  final String symbol;
  @override
  final String price;
  @override
  final String quantity;
  @override
  final int eventTime;
  @override
  final int tradeID;
  @override
  final int buyerOrderID;
  @override
  final int sellerOrderID;
  @override
  final int tradeTime;
  @override
  final bool marketMaker;
  @override
  final bool ignore;

  @override
  String toString() {
    return 'TradePayload(eventType: $eventType, symbol: $symbol, price: $price, quantity: $quantity, eventTime: $eventTime, tradeID: $tradeID, buyerOrderID: $buyerOrderID, sellerOrderID: $sellerOrderID, tradeTime: $tradeTime, marketMaker: $marketMaker, ignore: $ignore)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TradePayload &&
            const DeepCollectionEquality().equals(other.eventType, eventType) &&
            const DeepCollectionEquality().equals(other.symbol, symbol) &&
            const DeepCollectionEquality().equals(other.price, price) &&
            const DeepCollectionEquality().equals(other.quantity, quantity) &&
            const DeepCollectionEquality().equals(other.eventTime, eventTime) &&
            const DeepCollectionEquality().equals(other.tradeID, tradeID) &&
            const DeepCollectionEquality()
                .equals(other.buyerOrderID, buyerOrderID) &&
            const DeepCollectionEquality()
                .equals(other.sellerOrderID, sellerOrderID) &&
            const DeepCollectionEquality().equals(other.tradeTime, tradeTime) &&
            const DeepCollectionEquality()
                .equals(other.marketMaker, marketMaker) &&
            const DeepCollectionEquality().equals(other.ignore, ignore));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(eventType),
      const DeepCollectionEquality().hash(symbol),
      const DeepCollectionEquality().hash(price),
      const DeepCollectionEquality().hash(quantity),
      const DeepCollectionEquality().hash(eventTime),
      const DeepCollectionEquality().hash(tradeID),
      const DeepCollectionEquality().hash(buyerOrderID),
      const DeepCollectionEquality().hash(sellerOrderID),
      const DeepCollectionEquality().hash(tradeTime),
      const DeepCollectionEquality().hash(marketMaker),
      const DeepCollectionEquality().hash(ignore));

  @JsonKey(ignore: true)
  @override
  _$$_TradePayloadCopyWith<_$_TradePayload> get copyWith =>
      __$$_TradePayloadCopyWithImpl<_$_TradePayload>(this, _$identity);
}

abstract class _TradePayload implements TradePayload {
  const factory _TradePayload(
      {required final String eventType,
      required final String symbol,
      required final String price,
      required final String quantity,
      required final int eventTime,
      required final int tradeID,
      required final int buyerOrderID,
      required final int sellerOrderID,
      required final int tradeTime,
      required final bool marketMaker,
      required final bool ignore}) = _$_TradePayload;

  @override
  String get eventType => throw _privateConstructorUsedError;
  @override
  String get symbol => throw _privateConstructorUsedError;
  @override
  String get price => throw _privateConstructorUsedError;
  @override
  String get quantity => throw _privateConstructorUsedError;
  @override
  int get eventTime => throw _privateConstructorUsedError;
  @override
  int get tradeID => throw _privateConstructorUsedError;
  @override
  int get buyerOrderID => throw _privateConstructorUsedError;
  @override
  int get sellerOrderID => throw _privateConstructorUsedError;
  @override
  int get tradeTime => throw _privateConstructorUsedError;
  @override
  bool get marketMaker => throw _privateConstructorUsedError;
  @override
  bool get ignore => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_TradePayloadCopyWith<_$_TradePayload> get copyWith =>
      throw _privateConstructorUsedError;
}
